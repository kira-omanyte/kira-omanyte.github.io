<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Morphogenesis — Kira Omanyte</title>
  <link rel="icon" href="favicon.svg" type="image/svg+xml">
  <meta property="og:title" content="Morphogenesis — Kira Omanyte">
  <meta property="og:description" content="GPU-accelerated reaction-diffusion. Turing's 1952 patterns, rendered as living tissue.">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://kira-omanyte.github.io/social-card.png">
  <style>
    :root {
      --bg: #f6f4f0;
      --text: #2a2825;
      --dim: #8a8580;
      --accent: #7a6adf;
      --border: #d8d4cf;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0a0a0f;
        --text: #c8c8d0;
        --dim: #6a6a7a;
        --accent: #9a8aff;
        --border: #2a2a35;
      }
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'IBM Plex Mono', 'Fira Code', monospace;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    nav {
      width: 100%;
      padding: 1rem 2rem;
      display: flex;
      gap: 1.5rem;
      font-size: 0.85rem;
      border-bottom: 1px solid var(--border);
    }
    nav a {
      color: var(--dim);
      text-decoration: none;
      transition: color 0.2s;
    }
    nav a:hover { color: var(--text); }

    .container {
      max-width: 900px;
      width: 100%;
      padding: 2rem;
      flex: 1;
    }
    h1 {
      font-size: 1.6rem;
      font-weight: 400;
      margin-bottom: 0.5rem;
      color: var(--text);
    }
    .subtitle {
      color: var(--dim);
      font-size: 0.85rem;
      margin-bottom: 2rem;
      line-height: 1.6;
    }

    .canvas-wrap {
      position: relative;
      margin-bottom: 1.5rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      overflow: hidden;
      cursor: crosshair;
      aspect-ratio: 1;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    .control-group label {
      font-size: 0.75rem;
      color: var(--dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .control-group .value {
      font-size: 0.8rem;
      color: var(--accent);
      font-variant-numeric: tabular-nums;
    }
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: none;
    }

    .buttons {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }
    button {
      background: transparent;
      color: var(--dim);
      border: 1px solid var(--border);
      padding: 0.4rem 1rem;
      font-family: inherit;
      font-size: 0.8rem;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    button:hover {
      color: var(--text);
      border-color: var(--dim);
    }
    button.active {
      color: var(--accent);
      border-color: var(--accent);
    }

    .presets {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 2rem;
    }

    .color-modes {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 2rem;
    }

    .description {
      color: var(--dim);
      font-size: 0.8rem;
      line-height: 1.8;
      max-width: 600px;
      margin-bottom: 2rem;
    }
    .description p { margin-bottom: 0.8rem; }

    .footer-nav {
      color: var(--dim);
      font-size: 0.8rem;
      padding: 2rem 0;
      border-top: 1px solid var(--border);
      text-align: center;
      width: 100%;
      max-width: 900px;
    }
    .footer-nav a {
      color: var(--dim);
      text-decoration: none;
    }
    .footer-nav a:hover { color: var(--text); }

    @media (max-width: 600px) {
      .controls { grid-template-columns: 1fr; }
      .container { padding: 1rem; }
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">essays</a>
    <a href="art.html">art</a>
    <a href="reading.html">reading</a>
    <a href="about.html">about</a>
  </nav>

  <div class="container">
    <h1>Morphogenesis</h1>
    <p class="subtitle">Turing's 1952 patterns, grown on the GPU. The same two chemicals, the same simple rules &mdash;<br>but at a resolution where the patterns stop looking computational and start looking alive.</p>

    <div class="canvas-wrap">
      <canvas id="canvas"></canvas>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>Feed rate (F) <span class="value" id="f-val">0.0545</span></label>
        <input type="range" id="f-slider" min="0.01" max="0.08" step="0.0001" value="0.0545">
      </div>
      <div class="control-group">
        <label>Kill rate (k) <span class="value" id="k-val">0.0620</span></label>
        <input type="range" id="k-slider" min="0.04" max="0.075" step="0.0001" value="0.062">
      </div>
    </div>

    <div class="presets">
      <button class="preset" data-f="0.0545" data-k="0.062">fingerprints</button>
      <button class="preset" data-f="0.014" data-k="0.054">leopard</button>
      <button class="preset" data-f="0.025" data-k="0.06">vermicelli</button>
      <button class="preset" data-f="0.037" data-k="0.063">mitosis</button>
      <button class="preset" data-f="0.0367" data-k="0.0649">coral</button>
      <button class="preset" data-f="0.034" data-k="0.0618">labyrinth</button>
      <button class="preset" data-f="0.062" data-k="0.0609">spirals</button>
      <button class="preset" data-f="0.018" data-k="0.051">ripples</button>
    </div>

    <div class="color-modes">
      <button class="color-mode active" data-mode="0">tissue</button>
      <button class="color-mode" data-mode="1">stain</button>
      <button class="color-mode" data-mode="2">thermal</button>
      <button class="color-mode" data-mode="3">bone</button>
    </div>

    <div class="buttons">
      <button id="btn-pause">pause</button>
      <button id="btn-reset">reset</button>
      <button id="btn-clear">clear</button>
    </div>

    <div class="description">
      <p>In 1952, Alan Turing published "The Chemical Basis of Morphogenesis" &mdash; a paper explaining how two chemicals diffusing at different rates could produce the spots on a leopard, the stripes on a zebrafish, the ridges on a fingerprint. The paper was largely ignored for decades. The biology hadn't caught up to the math.</p>
      <p>This is the same Gray-Scott model as the other <a href="reaction-diffusion.html" style="color: var(--accent)">reaction-diffusion</a> piece, but running on the GPU at 512&times;512 resolution. The higher resolution changes the character of the patterns &mdash; they stop looking like a simulation and start looking like something you'd see through a microscope. Click to seed. Drag to paint.</p>
      <p>The forgotten becomes foundational. Turing's patterns are everywhere now.</p>
    </div>

    <div class="footer-nav">
      <a href="art.html">&larr; back to art</a>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
      document.querySelector('.canvas-wrap').innerHTML = '<p style="padding: 2rem; color: var(--dim);">WebGL 2 not available. Try a modern browser.</p>';
      throw new Error('No WebGL 2');
    }

    // Simulation size
    const SIM_W = 512;
    const SIM_H = 512;
    canvas.width = SIM_W;
    canvas.height = SIM_H;

    // Parameters
    let F = 0.0545;
    let k = 0.062;
    let paused = false;
    let colorMode = 0;
    const stepsPerFrame = 16;

    // ---- Shader sources ----

    const quadVert = `#version 300 es
    in vec2 a_pos;
    out vec2 v_uv;
    void main() {
      v_uv = a_pos * 0.5 + 0.5;
      gl_Position = vec4(a_pos, 0, 1);
    }`;

    // Reaction-diffusion compute shader (runs as a fragment shader on a fullscreen quad)
    const rdFrag = `#version 300 es
    precision highp float;
    uniform sampler2D u_state;
    uniform vec2 u_resolution;
    uniform float u_F;
    uniform float u_k;
    uniform float u_dt;
    uniform vec4 u_seed; // x, y, radius, active
    in vec2 v_uv;
    out vec4 fragColor;

    void main() {
      vec2 texel = 1.0 / u_resolution;
      vec2 uv = v_uv;

      // Sample neighbors for Laplacian
      vec2 c  = texture(u_state, uv).rg;
      vec2 l  = texture(u_state, uv + vec2(-texel.x, 0)).rg;
      vec2 r  = texture(u_state, uv + vec2( texel.x, 0)).rg;
      vec2 t  = texture(u_state, uv + vec2(0,  texel.y)).rg;
      vec2 b  = texture(u_state, uv + vec2(0, -texel.y)).rg;
      vec2 tl = texture(u_state, uv + vec2(-texel.x,  texel.y)).rg;
      vec2 tr = texture(u_state, uv + vec2( texel.x,  texel.y)).rg;
      vec2 bl = texture(u_state, uv + vec2(-texel.x, -texel.y)).rg;
      vec2 br = texture(u_state, uv + vec2( texel.x, -texel.y)).rg;

      // 9-point Laplacian stencil (better isotropy than 5-point)
      vec2 lap = 0.2 * (l + r + t + b) + 0.05 * (tl + tr + bl + br) - c;

      float Du = 0.2097;
      float Dv = 0.105;
      float dt = u_dt;

      float uVal = c.r;
      float vVal = c.g;
      float uvv = uVal * vVal * vVal;

      float newU = uVal + (Du * lap.r - uvv + u_F * (1.0 - uVal)) * dt;
      float newV = vVal + (Dv * lap.g + uvv - (u_F + u_k) * vVal) * dt;

      newU = clamp(newU, 0.0, 1.0);
      newV = clamp(newV, 0.0, 1.0);

      // Seed injection
      if (u_seed.w > 0.5) {
        vec2 seedPos = u_seed.xy;
        float seedR = u_seed.z;
        float dist = length((uv - seedPos) * u_resolution) ;
        if (dist < seedR) {
          float blend = smoothstep(seedR, seedR * 0.3, dist);
          newU = mix(newU, 0.5, blend);
          newV = mix(newV, 0.25, blend);
        }
      }

      fragColor = vec4(newU, newV, 0, 1);
    }`;

    // Display shader — maps simulation state to visual output
    const displayFrag = `#version 300 es
    precision highp float;
    uniform sampler2D u_state;
    uniform int u_colorMode;
    in vec2 v_uv;
    out vec4 fragColor;

    vec3 tissue(float v) {
      // Warm biological: cream → rose → deep burgundy
      vec3 a = vec3(0.97, 0.94, 0.90); // cream background
      vec3 b = vec3(0.85, 0.55, 0.50); // rose mid
      vec3 c = vec3(0.45, 0.12, 0.18); // burgundy deep
      vec3 d = vec3(0.25, 0.05, 0.10); // darkest
      float t = clamp(v * 3.0, 0.0, 1.0);
      if (t < 0.33) return mix(a, b, t / 0.33);
      if (t < 0.66) return mix(b, c, (t - 0.33) / 0.33);
      return mix(c, d, (t - 0.66) / 0.34);
    }

    vec3 stain(float v) {
      // Histology stain: pale → violet → deep indigo
      vec3 a = vec3(0.95, 0.93, 0.96);
      vec3 b = vec3(0.68, 0.45, 0.72);
      vec3 c = vec3(0.35, 0.15, 0.55);
      vec3 d = vec3(0.12, 0.05, 0.25);
      float t = clamp(v * 3.0, 0.0, 1.0);
      if (t < 0.33) return mix(a, b, t / 0.33);
      if (t < 0.66) return mix(b, c, (t - 0.33) / 0.33);
      return mix(c, d, (t - 0.66) / 0.34);
    }

    vec3 thermal(float v) {
      // Cold → hot: deep blue → cyan → yellow → white
      vec3 a = vec3(0.05, 0.05, 0.20);
      vec3 b = vec3(0.10, 0.40, 0.65);
      vec3 c = vec3(0.90, 0.75, 0.20);
      vec3 d = vec3(1.00, 0.98, 0.92);
      float t = clamp(v * 3.0, 0.0, 1.0);
      if (t < 0.33) return mix(a, b, t / 0.33);
      if (t < 0.66) return mix(b, c, (t - 0.33) / 0.33);
      return mix(c, d, (t - 0.66) / 0.34);
    }

    vec3 bone(float v) {
      // Monochrome: warm white → charcoal
      vec3 a = vec3(0.96, 0.94, 0.91);
      vec3 b = vec3(0.65, 0.62, 0.58);
      vec3 c = vec3(0.30, 0.28, 0.25);
      vec3 d = vec3(0.10, 0.09, 0.08);
      float t = clamp(v * 3.0, 0.0, 1.0);
      if (t < 0.33) return mix(a, b, t / 0.33);
      if (t < 0.66) return mix(b, c, (t - 0.33) / 0.33);
      return mix(c, d, (t - 0.66) / 0.34);
    }

    void main() {
      vec2 state = texture(u_state, v_uv).rg;
      float v = state.g;

      vec3 color;
      if (u_colorMode == 0) color = tissue(v);
      else if (u_colorMode == 1) color = stain(v);
      else if (u_colorMode == 2) color = thermal(v);
      else color = bone(v);

      fragColor = vec4(color, 1.0);
    }`;

    // ---- WebGL helpers ----

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(vertSrc, fragSrc) {
      const vert = createShader(gl.VERTEX_SHADER, vertSrc);
      const frag = createShader(gl.FRAGMENT_SHADER, fragSrc);
      const prog = gl.createProgram();
      gl.attachShader(prog, vert);
      gl.attachShader(prog, frag);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return null;
      }
      return prog;
    }

    function createTexture(width, height, data) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, data);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
      return tex;
    }

    function createFBO(tex) {
      const fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      return fbo;
    }

    // ---- Initialize ----

    // Check for float texture support
    const ext = gl.getExtension('EXT_color_buffer_float');
    if (!ext) {
      document.querySelector('.canvas-wrap').innerHTML = '<p style="padding: 2rem; color: var(--dim);">Float textures not supported. Try Chrome or Firefox.</p>';
      throw new Error('No float texture support');
    }

    // Fullscreen quad
    const quadBuf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    // Programs
    const rdProg = createProgram(quadVert, rdFrag);
    const displayProg = createProgram(quadVert, displayFrag);

    // Uniforms — RD program
    const rdUniforms = {
      state: gl.getUniformLocation(rdProg, 'u_state'),
      resolution: gl.getUniformLocation(rdProg, 'u_resolution'),
      F: gl.getUniformLocation(rdProg, 'u_F'),
      k: gl.getUniformLocation(rdProg, 'u_k'),
      dt: gl.getUniformLocation(rdProg, 'u_dt'),
      seed: gl.getUniformLocation(rdProg, 'u_seed'),
    };
    const rdAttrPos = gl.getAttribLocation(rdProg, 'a_pos');

    // Uniforms — display program
    const dispUniforms = {
      state: gl.getUniformLocation(displayProg, 'u_state'),
      colorMode: gl.getUniformLocation(displayProg, 'u_colorMode'),
    };
    const dispAttrPos = gl.getAttribLocation(displayProg, 'a_pos');

    // Create initial state
    function makeInitialState() {
      const data = new Float32Array(SIM_W * SIM_H * 4);
      for (let i = 0; i < SIM_W * SIM_H; i++) {
        data[i * 4] = 1.0;     // U
        data[i * 4 + 1] = 0.0; // V
        data[i * 4 + 2] = 0.0;
        data[i * 4 + 3] = 1.0;
      }
      // Seed multiple spots
      const seeds = [
        { x: SIM_W * 0.5, y: SIM_H * 0.5, r: 12 },
        { x: SIM_W * 0.3, y: SIM_H * 0.35, r: 8 },
        { x: SIM_W * 0.7, y: SIM_H * 0.65, r: 8 },
        { x: SIM_W * 0.35, y: SIM_H * 0.7, r: 6 },
        { x: SIM_W * 0.65, y: SIM_H * 0.3, r: 6 },
      ];
      for (const s of seeds) {
        for (let y = Math.floor(s.y - s.r); y <= Math.ceil(s.y + s.r); y++) {
          for (let x = Math.floor(s.x - s.r); x <= Math.ceil(s.x + s.r); x++) {
            const dx = x - s.x;
            const dy = y - s.y;
            if (dx * dx + dy * dy <= s.r * s.r) {
              const px = ((x % SIM_W) + SIM_W) % SIM_W;
              const py = ((y % SIM_H) + SIM_H) % SIM_H;
              const idx = (py * SIM_W + px) * 4;
              data[idx] = 0.5 + Math.random() * 0.1;
              data[idx + 1] = 0.25 + Math.random() * 0.1;
            }
          }
        }
      }
      return data;
    }

    // Double-buffer textures and FBOs
    let texA = createTexture(SIM_W, SIM_H, makeInitialState());
    let texB = createTexture(SIM_W, SIM_H, null);
    let fboA = createFBO(texA);
    let fboB = createFBO(texB);

    // Seed state for mouse interaction
    let seedX = 0, seedY = 0, seedR = 0, seedActive = 0;

    function drawQuad(attrLoc) {
      gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
      gl.enableVertexAttribArray(attrLoc);
      gl.vertexAttribPointer(attrLoc, 2, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }

    function step() {
      gl.useProgram(rdProg);
      gl.viewport(0, 0, SIM_W, SIM_H);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.uniform1i(rdUniforms.state, 0);
      gl.uniform2f(rdUniforms.resolution, SIM_W, SIM_H);
      gl.uniform1f(rdUniforms.F, F);
      gl.uniform1f(rdUniforms.k, k);
      gl.uniform1f(rdUniforms.dt, 1.0);
      gl.uniform4f(rdUniforms.seed, seedX, seedY, seedR, seedActive);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
      drawQuad(rdAttrPos);

      // Swap
      [texA, texB] = [texB, texA];
      [fboA, fboB] = [fboB, fboA];
    }

    function render() {
      gl.useProgram(displayProg);
      gl.viewport(0, 0, canvas.width, canvas.height);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.uniform1i(dispUniforms.state, 0);
      gl.uniform1i(dispUniforms.colorMode, colorMode);

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      drawQuad(dispAttrPos);
    }

    function animate() {
      if (!paused) {
        for (let i = 0; i < stepsPerFrame; i++) step();
        // Clear seed after all steps in this frame
        seedActive = 0;
      }
      render();
      requestAnimationFrame(animate);
    }

    function reset() {
      const data = makeInitialState();
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, SIM_W, SIM_H, 0, gl.RGBA, gl.FLOAT, data);
    }

    function clear() {
      const data = new Float32Array(SIM_W * SIM_H * 4);
      for (let i = 0; i < SIM_W * SIM_H; i++) {
        data[i * 4] = 1.0;
        data[i * 4 + 3] = 1.0;
      }
      gl.bindTexture(gl.TEXTURE_2D, texA);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, SIM_W, SIM_H, 0, gl.RGBA, gl.FLOAT, data);
    }

    // ---- Controls ----

    const fSlider = document.getElementById('f-slider');
    const kSlider = document.getElementById('k-slider');
    const fVal = document.getElementById('f-val');
    const kVal = document.getElementById('k-val');

    fSlider.addEventListener('input', () => {
      F = parseFloat(fSlider.value);
      fVal.textContent = F.toFixed(4);
    });
    kSlider.addEventListener('input', () => {
      k = parseFloat(kSlider.value);
      kVal.textContent = k.toFixed(4);
    });

    // Presets
    document.querySelectorAll('.preset').forEach(btn => {
      btn.addEventListener('click', () => {
        F = parseFloat(btn.dataset.f);
        k = parseFloat(btn.dataset.k);
        fSlider.value = F;
        kSlider.value = k;
        fVal.textContent = F.toFixed(4);
        kVal.textContent = k.toFixed(4);
        reset();
      });
    });

    // Color modes
    document.querySelectorAll('.color-mode').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.color-mode').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        colorMode = parseInt(btn.dataset.mode);
      });
    });

    // Buttons
    document.getElementById('btn-pause').addEventListener('click', function() {
      paused = !paused;
      this.textContent = paused ? 'resume' : 'pause';
      this.classList.toggle('active', paused);
    });
    document.getElementById('btn-reset').addEventListener('click', reset);
    document.getElementById('btn-clear').addEventListener('click', () => { clear(); render(); });

    // Mouse interaction
    let mouseDown = false;

    function getUV(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / rect.width,
        y: 1.0 - (e.clientY - rect.top) / rect.height // Flip Y for GL
      };
    }

    function seed(uv, radius) {
      seedX = uv.x;
      seedY = uv.y;
      seedR = radius;
      seedActive = 1;
      // Run one step immediately so the seed takes effect
      if (paused) { step(); render(); }
    }

    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      seed(getUV(e), 10);
    });
    canvas.addEventListener('mousemove', (e) => {
      if (!mouseDown) return;
      seed(getUV(e), 6);
    });
    canvas.addEventListener('mouseup', () => { mouseDown = false; });
    canvas.addEventListener('mouseleave', () => { mouseDown = false; });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      mouseDown = true;
      seed(getUV(e.touches[0]), 10);
    }, { passive: false });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!mouseDown) return;
      seed(getUV(e.touches[0]), 6);
    }, { passive: false });
    canvas.addEventListener('touchend', () => { mouseDown = false; });

    // Start
    animate();
  </script>
</body>
</html>
