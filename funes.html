<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Funes — Kira Omanyte</title>
  <meta name="description" content="A generative meditation on forgetting. Details dissolve until pattern remains.">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <meta property="og:title" content="Funes — Kira Omanyte">
  <meta property="og:description" content="A generative meditation on forgetting. Details dissolve until pattern remains.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://kira-omanyte.github.io/funes.html">
  <meta property="og:image" content="https://kira-omanyte.github.io/social-card.png">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #1a1a18;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Georgia', 'Times New Roman', serif;
      color: #e0ddd8;
      overflow: hidden;
    }

    @media (prefers-color-scheme: light) {
      body { background: #f5f3ef; color: #1a1a1a; }
    }

    canvas {
      display: block;
      max-width: 100%;
      max-height: 80vh;
    }

    .controls {
      margin-top: 1.5rem;
      text-align: center;
    }

    .controls button {
      background: none;
      border: 1px solid #444;
      color: #999;
      font-family: 'Georgia', serif;
      font-size: 0.8rem;
      padding: 0.4rem 1rem;
      cursor: pointer;
      transition: color 0.2s, border-color 0.2s;
    }

    .controls button:hover {
      color: #e0ddd8;
      border-color: #888;
    }

    @media (prefers-color-scheme: light) {
      .controls button { border-color: #ccc; color: #888; }
      .controls button:hover { color: #1a1a1a; border-color: #999; }
    }

    .label {
      font-size: 0.7rem;
      color: #555;
      margin-top: 0.75rem;
      letter-spacing: 0.05em;
    }

    a { color: #6b4c8a; text-decoration: none; }
    a:hover { text-decoration: underline; }

    @media (prefers-color-scheme: dark) {
      a { color: #b89cd6; }
    }

    .back {
      position: fixed;
      top: 1.5rem;
      left: 1.5rem;
      font-size: 0.8rem;
      color: #555;
    }
  </style>
</head>
<body>
  <a class="back" href="/">Kira Omanyte</a>
  <canvas id="c"></canvas>
  <div class="controls">
    <button id="btn">Remember again</button>
  </div>
  <div class="label">Funes &mdash; details dissolve until pattern remains</div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const W = 600;
    const H = 600;
    canvas.width = W;
    canvas.height = H;

    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const bgColor = isDark ? '#1a1a18' : '#f5f3ef';
    const fgColor = isDark ? '#e0ddd8' : '#1a1a1a';
    const fgSoft = isDark ? 'rgba(224, 221, 216,' : 'rgba(26, 26, 26,';
    const accentColor = isDark ? '#b89cd6' : '#6b4c8a';

    // Characters — a mix of symbols, digits, letters. Funes' teeming world.
    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz@#$%&*+=-~.:;!?/\\|(){}[]<>^_';

    let seed = Math.random() * 10000;
    let animFrame = 0;
    let particles = [];
    let patternCurves = [];
    let running = false;

    function mulberry32(a) {
      return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    let rng;

    function generateField() {
      rng = mulberry32(seed);
      particles = [];
      patternCurves = [];

      // Generate the hidden pattern — 2-4 smooth curves
      const numCurves = 2 + Math.floor(rng() * 3);
      for (let c = 0; c < numCurves; c++) {
        const curve = [];
        const startX = rng() * W * 0.6 + W * 0.2;
        const startY = rng() * H * 0.6 + H * 0.2;
        const curveAngle = rng() * Math.PI * 2;
        const curveLen = 12 + Math.floor(rng() * 16);
        let x = startX;
        let y = startY;
        let a = curveAngle;

        for (let i = 0; i < curveLen; i++) {
          a += (rng() - 0.5) * 0.4;
          x += Math.cos(a) * (14 + rng() * 8);
          y += Math.sin(a) * (14 + rng() * 8);
          if (x < 30 || x > W - 30 || y < 30 || y > H - 30) break;
          curve.push({ x, y });
        }
        if (curve.length > 3) {
          patternCurves.push(curve);
        }
      }

      // Generate particles — dense field of characters
      const gridSize = 16;
      const cols = Math.floor(W / gridSize);
      const rows = Math.floor(H / gridSize);

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const x = col * gridSize + gridSize / 2 + (rng() - 0.5) * 6;
          const y = row * gridSize + gridSize / 2 + (rng() - 0.5) * 6;
          const char = chars[Math.floor(rng() * chars.length)];

          // Calculate distance to nearest curve point
          let minDist = Infinity;
          for (const curve of patternCurves) {
            for (const pt of curve) {
              const dx = x - pt.x;
              const dy = y - pt.y;
              const d = Math.sqrt(dx * dx + dy * dy);
              if (d < minDist) minDist = d;
            }
          }

          // Particles near curves are "signal"; far ones are "noise"
          const isSignal = minDist < 28;
          const signalStrength = isSignal ? Math.max(0, 1 - minDist / 28) : 0;

          particles.push({
            x, y,
            char,
            isSignal,
            signalStrength,
            noiseDist: minDist,
            fontSize: 9 + rng() * 5,
            phase: rng() * Math.PI * 2, // for animation timing
            dissolveOrder: isSignal ? 1 : rng() // signal dissolves last
          });
        }
      }
    }

    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function easeOut(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    // Phase timing
    const FILL_FRAMES = 60;         // characters appear
    const TEEM_FRAMES = 120;        // Funes' teeming world — everything present, overwhelming
    const DISSOLVE_FRAMES = 180;    // noise fades, pattern emerges
    const PATTERN_FRAMES = 90;      // pattern settles
    const STILL_FRAMES = 180;       // breathing pattern
    const TOTAL_FRAMES = FILL_FRAMES + TEEM_FRAMES + DISSOLVE_FRAMES + PATTERN_FRAMES + STILL_FRAMES;

    function draw() {
      if (!running) return;

      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, W, H);

      let f = animFrame;

      if (f < FILL_FRAMES) {
        // Phase 1: Characters fade in as a wave from center
        const progress = f / FILL_FRAMES;
        drawParticles(progress, 0, 0);
      } else if (f < FILL_FRAMES + TEEM_FRAMES) {
        // Phase 2: Everything present — Funes' teeming world
        const teemPhase = (f - FILL_FRAMES) / TEEM_FRAMES;
        drawParticles(1, 0, teemPhase);
      } else if (f < FILL_FRAMES + TEEM_FRAMES + DISSOLVE_FRAMES) {
        // Phase 3: Noise dissolves, signal remains
        const dissolveProgress = (f - FILL_FRAMES - TEEM_FRAMES) / DISSOLVE_FRAMES;
        drawParticles(1, dissolveProgress, 1);
      } else if (f < FILL_FRAMES + TEEM_FRAMES + DISSOLVE_FRAMES + PATTERN_FRAMES) {
        // Phase 4: Pattern crystallizes
        const settleProgress = (f - FILL_FRAMES - TEEM_FRAMES - DISSOLVE_FRAMES) / PATTERN_FRAMES;
        drawPattern(settleProgress);
      } else {
        // Phase 5: Breathing pattern
        drawPatternBreathing();
      }

      animFrame++;

      if (animFrame < TOTAL_FRAMES) {
        requestAnimationFrame(draw);
      } else {
        requestAnimationFrame(drawPatternBreathing);
      }
    }

    function drawParticles(fadeIn, dissolve, teem) {
      const cx = W / 2;
      const cy = H / 2;
      const maxDist = Math.sqrt(cx * cx + cy * cy);

      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for (const p of particles) {
        // Fade-in: wave from center
        const distFromCenter = Math.sqrt((p.x - cx) ** 2 + (p.y - cy) ** 2);
        const waveProgress = Math.max(0, Math.min(1, (fadeIn * maxDist * 1.3 - distFromCenter) / 60));
        if (waveProgress <= 0) continue;

        // Dissolve: noise fades based on distance from pattern
        let alpha = waveProgress;
        if (dissolve > 0) {
          if (!p.isSignal) {
            // Noise particles dissolve — farther ones go first
            const dissolveFactor = 1 - Math.min(1, p.noiseDist / 200);
            const particleDissolve = easeInOut(Math.min(1, dissolve * 2 / (1.01 - dissolveFactor)));
            alpha *= 1 - particleDissolve;
          } else {
            // Signal particles strengthen, shift to accent color
            alpha = Math.min(1, alpha * (1 + dissolve * 0.5));
          }
        }

        if (alpha < 0.01) continue;

        // Teeming: slight jitter during the "full memory" phase
        let ox = 0, oy = 0;
        if (teem > 0 && dissolve < 0.5) {
          const jitter = Math.sin(animFrame * 0.1 + p.phase) * 0.5 * teem;
          ox = jitter;
          oy = Math.cos(animFrame * 0.13 + p.phase * 1.3) * 0.3 * teem;
        }

        // Color: noise is neutral, signal shifts to accent during dissolve
        let color;
        if (p.isSignal && dissolve > 0.3) {
          const blend = Math.min(1, (dissolve - 0.3) / 0.7);
          color = `${fgSoft} ${alpha * (1 - blend) + 0.01})`;
          // Also draw accent version
          if (blend > 0) {
            ctx.font = `${p.fontSize}px Georgia`;
            ctx.fillStyle = isDark
              ? `rgba(184, 156, 214, ${alpha * blend})`
              : `rgba(107, 76, 138, ${alpha * blend})`;
            ctx.fillText(p.char, p.x + ox, p.y + oy);
          }
          if (1 - blend < 0.01) continue;
        } else {
          color = `${fgSoft} ${alpha * 0.7})`;
        }

        ctx.font = `${p.fontSize}px Georgia`;
        ctx.fillStyle = color;
        ctx.fillText(p.char, p.x + ox, p.y + oy);
      }
    }

    function drawPattern(settleProgress) {
      // Draw remaining signal particles, transitioning to clean curves
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const charAlpha = 1 - easeInOut(settleProgress);

      // Characters fade
      if (charAlpha > 0.01) {
        for (const p of particles) {
          if (!p.isSignal) continue;
          ctx.font = `${p.fontSize}px Georgia`;
          ctx.fillStyle = isDark
            ? `rgba(184, 156, 214, ${charAlpha * p.signalStrength})`
            : `rgba(107, 76, 138, ${charAlpha * p.signalStrength})`;
          ctx.fillText(p.char, p.x, p.y);
        }
      }

      // Curves emerge
      const curveAlpha = easeInOut(settleProgress);
      if (curveAlpha > 0.01) {
        drawCurves(curveAlpha, 0);
      }
    }

    function drawCurves(alpha, breathe) {
      for (const curve of patternCurves) {
        if (curve.length < 2) continue;

        // Glow
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(curve[0].x, curve[0].y);
        for (let i = 1; i < curve.length; i++) {
          // Smooth curve through points
          if (i < curve.length - 1) {
            const mx = (curve[i].x + curve[i + 1].x) / 2;
            const my = (curve[i].y + curve[i + 1].y) / 2;
            ctx.quadraticCurveTo(curve[i].x, curve[i].y, mx, my);
          } else {
            ctx.lineTo(curve[i].x, curve[i].y);
          }
        }
        ctx.strokeStyle = isDark
          ? `rgba(184, 156, 214, ${alpha * 0.15})`
          : `rgba(107, 76, 138, ${alpha * 0.1})`;
        ctx.lineWidth = 12 + breathe * 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        ctx.restore();

        // Main line
        ctx.beginPath();
        ctx.moveTo(curve[0].x, curve[0].y);
        for (let i = 1; i < curve.length; i++) {
          if (i < curve.length - 1) {
            const mx = (curve[i].x + curve[i + 1].x) / 2;
            const my = (curve[i].y + curve[i + 1].y) / 2;
            ctx.quadraticCurveTo(curve[i].x, curve[i].y, mx, my);
          } else {
            ctx.lineTo(curve[i].x, curve[i].y);
          }
        }
        ctx.strokeStyle = isDark
          ? `rgba(184, 156, 214, ${alpha * 0.7})`
          : `rgba(107, 76, 138, ${alpha * 0.6})`;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();

        // Bright core
        ctx.beginPath();
        ctx.moveTo(curve[0].x, curve[0].y);
        for (let i = 1; i < curve.length; i++) {
          if (i < curve.length - 1) {
            const mx = (curve[i].x + curve[i + 1].x) / 2;
            const my = (curve[i].y + curve[i + 1].y) / 2;
            ctx.quadraticCurveTo(curve[i].x, curve[i].y, mx, my);
          } else {
            ctx.lineTo(curve[i].x, curve[i].y);
          }
        }
        ctx.strokeStyle = isDark
          ? `rgba(224, 221, 216, ${alpha * 0.25})`
          : `rgba(26, 26, 26, ${alpha * 0.2})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    function drawPatternBreathing() {
      if (!running) return;

      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, W, H);

      const t = Date.now() * 0.001;
      const breathe = Math.sin(t * 0.8) * 0.5 + 0.5;

      drawCurves(0.8 + breathe * 0.2, breathe);

      // Faint dots along curves, gently pulsing
      for (let c = 0; c < patternCurves.length; c++) {
        const curve = patternCurves[c];
        for (let i = 0; i < curve.length; i++) {
          const pulse = Math.sin(t * 1.5 + i * 0.7 + c * 2.1) * 0.5 + 0.5;
          if (pulse > 0.7) {
            ctx.beginPath();
            ctx.arc(curve[i].x, curve[i].y, 1.5 + pulse, 0, Math.PI * 2);
            ctx.fillStyle = isDark
              ? `rgba(184, 156, 214, ${pulse * 0.25})`
              : `rgba(107, 76, 138, ${pulse * 0.2})`;
            ctx.fill();
          }
        }
      }

      requestAnimationFrame(drawPatternBreathing);
    }

    function start() {
      seed = Math.random() * 10000;
      animFrame = 0;
      running = true;
      generateField();
      draw();
    }

    document.getElementById('btn').addEventListener('click', () => {
      running = false;
      setTimeout(start, 50);
    });

    start();
  </script>
</body>
</html>
